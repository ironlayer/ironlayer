"""
Format an IronLayer plan as a GitHub PR comment (Markdown).

Produces a developer-friendly data impact analysis including:
  - Impact summary (direct vs downstream, column-level changes)
  - Execution steps table with column change indicators
  - Collapsible column change details
  - Collapsible impact graph (ASCII dependency tree)
  - Optional AI advisory section
  - Contract violations, cosmetic changes, full plan JSON

Usage:
    python format_comment.py \
        --status success|empty|failed \
        --plan-json /path/to/plan.json \
        --base-sha abc123 \
        --head-sha def456 \
        --error "optional error message" \
        --advisory-json /path/to/advisory.json \
        --output /path/to/comment.md
"""
from __future__ import annotations

import argparse
import json
import sys
from pathlib import Path


FOOTER = "\n---\n*Generated by [IronLayer](https://ironlayer.app)*"


# ---------------------------------------------------------------------------
# Risk classification
# ---------------------------------------------------------------------------


def _compute_risk(
    plan: dict,
    advisory: dict | None,
) -> tuple[str, str]:
    """Return ``(risk_level, risk_emoji)`` based on plan content.

    Risk levels:
    - high:   any BREAKING contract violations
    - review: any removed columns, or advisory risk_score >= 7
    - low:    everything else
    """
    summary = plan.get("summary", {})
    breaking = summary.get("breaking_contract_violations", 0)
    if breaking > 0:
        return "high risk", ":red_circle:"

    # Check for removed columns across all steps.
    steps = plan.get("steps", [])
    has_removed = any(
        len(s.get("diff_detail", {}).get("columns_removed", []) if s.get("diff_detail") else []) > 0
        for s in steps
    )
    advisory_risk = (advisory or {}).get("risk_score", 0)
    if has_removed or advisory_risk >= 7:
        return "review", ":yellow_circle:"

    return "low risk", ":green_circle:"


# ---------------------------------------------------------------------------
# Column change aggregation
# ---------------------------------------------------------------------------


def _aggregate_column_counts(steps: list[dict]) -> tuple[int, int, int]:
    """Return ``(added, removed, modified)`` column counts across all steps."""
    added = removed = modified = 0
    for step in steps:
        dd = step.get("diff_detail")
        if dd:
            added += len(dd.get("columns_added", []))
            removed += len(dd.get("columns_removed", []))
            modified += len(dd.get("columns_modified", []))
    return added, removed, modified


def _column_summary_cell(step: dict) -> str:
    """Build a compact column change indicator for the steps table.

    Examples: ``+2 ~1``, ``-1``, ``+3 -1 ~2``, or empty string.
    """
    dd = step.get("diff_detail")
    if not dd:
        return ""
    parts: list[str] = []
    n_added = len(dd.get("columns_added", []))
    n_removed = len(dd.get("columns_removed", []))
    n_modified = len(dd.get("columns_modified", []))
    if n_added:
        parts.append(f"+{n_added}")
    if n_removed:
        parts.append(f"-{n_removed}")
    if n_modified:
        parts.append(f"~{n_modified}")
    return " ".join(parts)


# ---------------------------------------------------------------------------
# Impact graph (ASCII tree)
# ---------------------------------------------------------------------------


def _build_impact_graph(steps: list[dict]) -> list[str]:
    """Build an ASCII dependency tree from plan steps.

    Returns a list of lines representing the tree.  The tree is built from
    ``depends_on`` relationships and is sorted deterministically.
    """
    if not steps:
        return []

    # Build step_id -> step lookup and adjacency.
    step_by_id: dict[str, dict] = {}
    children: dict[str, list[str]] = {}
    all_child_ids: set[str] = set()

    for step in steps:
        sid = step.get("step_id", "")
        step_by_id[sid] = step
        for dep_id in step.get("depends_on", []):
            children.setdefault(dep_id, []).append(sid)
            all_child_ids.add(sid)

    # Root steps are those that don't appear as children.
    root_ids = [s["step_id"] for s in steps if s["step_id"] not in all_child_ids]

    lines: list[str] = []

    def _render(step_id: str, prefix: str, is_last: bool, is_root: bool) -> None:
        step = step_by_id.get(step_id, {})
        model = step.get("model", "unknown")
        reason = step.get("reason", "")

        # Classify as CHANGED (direct) or DOWNSTREAM.
        is_direct = reason in ("SQL logic changed", "new model added")
        label = "CHANGED" if is_direct else "DOWNSTREAM"

        if is_root:
            connector = ""
            child_prefix = ""
        else:
            connector = "`-- " if is_last else "|-- "
            child_prefix = "    " if is_last else "|   "

        lines.append(f"{prefix}{connector}{model}  <- {label}")

        child_ids = sorted(children.get(step_id, []), key=lambda x: step_by_id.get(x, {}).get("model", ""))
        for i, child_id in enumerate(child_ids):
            _render(
                child_id,
                prefix + child_prefix,
                is_last=(i == len(child_ids) - 1),
                is_root=False,
            )

    for i, root_id in enumerate(root_ids):
        if i > 0:
            lines.append("")  # Blank line between roots.
        _render(root_id, "", is_last=(i == len(root_ids) - 1), is_root=True)

    return lines


# ---------------------------------------------------------------------------
# Formatting functions
# ---------------------------------------------------------------------------


def format_failed(error: str, base_sha: str, head_sha: str) -> str:
    """Format a comment for a failed plan generation."""
    lines = [
        "## :rotating_light: IronLayer Plan",
        "",
        f"`{base_sha[:12]}` :arrow_right: `{head_sha[:12]}`",
        "",
        "**Plan generation failed.**",
        "",
    ]
    if error.strip():
        lines += [
            "<details>",
            "<summary>Error details</summary>",
            "",
            "```",
            error.strip(),
            "```",
            "",
            "</details>",
        ]
    lines.append(FOOTER)
    return "\n".join(lines)


def format_empty(base_sha: str, head_sha: str) -> str:
    """Format a comment when no model changes are detected."""
    lines = [
        "## :white_check_mark: IronLayer Plan",
        "",
        f"`{base_sha[:12]}` :arrow_right: `{head_sha[:12]}`",
        "",
        "**No model changes detected.** Nothing to execute.",
        FOOTER,
    ]
    return "\n".join(lines)


def format_success(
    plan: dict,
    base_sha: str,
    head_sha: str,
    advisory: dict | None = None,
) -> str:
    """Format a rich data impact analysis comment for a successful plan."""
    summary = plan.get("summary", {})
    steps = plan.get("steps", [])
    plan_id = plan.get("plan_id", "unknown")

    total_steps = summary.get("total_steps", len(steps))
    estimated_cost = summary.get("estimated_cost_usd", 0)
    models_changed = summary.get("models_changed", [])
    cosmetic_skipped = summary.get("cosmetic_changes_skipped", [])
    breaking_count = summary.get("breaking_contract_violations", 0)

    risk_level, risk_emoji = _compute_risk(plan, advisory)
    cols_added, cols_removed, cols_modified = _aggregate_column_counts(steps)

    # ── Header ────────────────────────────────────────────────────────────
    if breaking_count > 0:
        icon = ":warning:"
    else:
        icon = ":hammer_and_wrench:"

    lines = [
        f"## {icon} IronLayer Plan &nbsp;·&nbsp; "
        f"**{total_steps} step{'s' if total_steps != 1 else ''}** &nbsp;·&nbsp; "
        f"**${estimated_cost:.2f}** est. &nbsp;·&nbsp; "
        f"{risk_emoji} {risk_level}",
        "",
        f"`{base_sha[:12]}` :arrow_right: `{head_sha[:12]}`",
        "",
    ]

    # ── Breaking contract violations banner ──────────────────────────────
    if breaking_count > 0:
        lines += [
            f"> :rotating_light: **{breaking_count} breaking contract "
            f"violation{'s' if breaking_count != 1 else ''}** detected. "
            "Review before merging.",
            "",
        ]

    # ── Impact summary ───────────────────────────────────────────────────
    direct_count = sum(
        1
        for s in steps
        if s.get("reason") in ("SQL logic changed", "new model added")
    )
    downstream_count = total_steps - direct_count

    impact_parts = [f"**{direct_count} model{'s' if direct_count != 1 else ''} changed directly**"]
    if downstream_count > 0:
        impact_parts.append(
            f"{downstream_count} downstream model{'s' if downstream_count != 1 else ''} affected"
        )

    lines.append(f"> {' · '.join(impact_parts)}")

    if cols_added or cols_removed or cols_modified:
        col_parts: list[str] = []
        if cols_added:
            col_parts.append(f"+{cols_added} added")
        if cols_removed:
            col_parts.append(f"-{cols_removed} removed")
        if cols_modified:
            col_parts.append(f"~{cols_modified} modified")
        lines.append(f"> Columns: {' · '.join(col_parts)}")

    lines.append("")

    # ── Steps table ──────────────────────────────────────────────────────
    if steps:
        lines += [
            "### Execution Steps",
            "",
            "| # | Model | Type | Columns | Reason | Cost |",
            "|--:|-------|------|---------|--------|-----:|",
        ]
        for i, step in enumerate(steps, 1):
            model = step.get("model", "unknown")
            run_type = step.get("run_type", "UNKNOWN")
            reason = step.get("reason", "")
            cost = step.get("estimated_cost_usd", 0)

            # Truncate long reasons.
            if len(reason) > 50:
                reason = reason[:47] + "..."

            run_badge = (
                ":arrows_counterclockwise:" if run_type == "INCREMENTAL" else ":arrow_right:"
            )
            col_cell = _column_summary_cell(step)
            lines.append(
                f"| {i} | `{model}` | {run_badge} {run_type} | {col_cell} | {reason} | ${cost:.2f} |"
            )
        lines.append("")

    # ── Column changes (collapsible) ─────────────────────────────────────
    steps_with_diff = [s for s in steps if s.get("diff_detail")]
    if steps_with_diff:
        lines += [
            "<details>",
            f"<summary>:bar_chart: Column Changes ({len(steps_with_diff)} "
            f"model{'s' if len(steps_with_diff) != 1 else ''})</summary>",
            "",
        ]
        for step in steps_with_diff:
            dd = step["diff_detail"]
            model = step.get("model", "unknown")
            lines.append(f"**`{model}`**")

            added = dd.get("columns_added", [])
            removed = dd.get("columns_removed", [])
            modified = dd.get("columns_modified", [])

            if added:
                col_list = ", ".join(f"`{c}`" for c in sorted(added))
                lines.append(f"- :heavy_plus_sign: {col_list}")
            if removed:
                col_list = ", ".join(f"`{c}`" for c in sorted(removed))
                lines.append(f"- :heavy_minus_sign: {col_list}")
            if modified:
                col_list = ", ".join(f"`{c}`" for c in sorted(modified))
                lines.append(f"- :pencil2: {col_list} (expression changed)")
            lines.append("")

        lines += ["</details>", ""]

    # ── Impact graph (collapsible) ───────────────────────────────────────
    if len(steps) > 1:
        graph_lines = _build_impact_graph(steps)
        if graph_lines:
            lines += [
                "<details>",
                "<summary>:deciduous_tree: Impact Graph</summary>",
                "",
                "```",
            ]
            lines.extend(graph_lines)
            lines += [
                "```",
                "",
                "</details>",
                "",
            ]

    # ── AI Advisory (collapsible) ────────────────────────────────────────
    if advisory and advisory.get("risk_score") is not None:
        risk_score = advisory.get("risk_score", 0)
        risk_label = advisory.get("risk_label", "unknown")
        category = advisory.get("category", "")
        review_notes = advisory.get("review_notes", [])
        adv_cost = advisory.get("estimated_cost_usd")

        # Risk score color.
        if risk_score >= 7:
            score_indicator = ":red_circle:"
        elif risk_score >= 4:
            score_indicator = ":yellow_circle:"
        else:
            score_indicator = ":green_circle:"

        lines += [
            "<details>",
            "<summary>:robot: AI Advisory</summary>",
            "",
            "| Metric | Value |",
            "|--------|-------|",
            f"| Risk Score | {risk_score}/10 {score_indicator} |",
        ]
        if category:
            lines.append(f"| Category | {category.replace('_', ' ').title()} |")
        if adv_cost is not None:
            lines.append(f"| Est. Cost | ${adv_cost:.2f} |")
        lines.append("")

        if review_notes:
            lines.append("**Review Notes:**")
            for note in review_notes:
                lines.append(f"- {note}")
            lines.append("")

        lines += ["</details>", ""]

    # ── Contract violations (collapsible) ────────────────────────────────
    all_violations = []
    for step in steps:
        for v in step.get("contract_violations", []):
            all_violations.append({"model": step.get("model", "unknown"), **v})

    if all_violations:
        lines += [
            "<details>",
            f"<summary>:clipboard: Contract Violations ({len(all_violations)})</summary>",
            "",
            "| Model | Column | Type | Severity | Message |",
            "|-------|--------|------|----------|---------|",
        ]
        for v in all_violations:
            severity = v.get("severity", "INFO")
            sev_icon = {
                "BREAKING": ":red_circle:",
                "WARNING": ":yellow_circle:",
                "INFO": ":blue_circle:",
            }.get(severity, ":white_circle:")
            lines.append(
                f"| `{v['model']}` | `{v.get('column_name', '-')}` | "
                f"{v.get('violation_type', '-')} | {sev_icon} {severity} | "
                f"{v.get('message', '-')} |"
            )
        lines += ["", "</details>", ""]

    # ── Cosmetic changes skipped (collapsible) ───────────────────────────
    if cosmetic_skipped:
        lines += [
            "<details>",
            f"<summary>:fast_forward: Cosmetic changes skipped ({len(cosmetic_skipped)})</summary>",
            "",
            "These models had whitespace/comment-only changes and do not require re-execution:",
            "",
        ]
        for m in cosmetic_skipped:
            lines.append(f"- `{m}`")
        lines += ["", "</details>", ""]

    # ── Full plan JSON (collapsible) ─────────────────────────────────────
    if steps:
        plan_json_compact = json.dumps(plan, indent=2, sort_keys=True)
        lines += [
            "<details>",
            "<summary>:page_facing_up: Full plan JSON</summary>",
            "",
            "```json",
            plan_json_compact,
            "```",
            "",
            "</details>",
            "",
        ]

    # ── Footer ───────────────────────────────────────────────────────────
    lines.append(f"<sub>Plan ID: `{plan_id[:16]}`</sub>")
    lines.append(FOOTER)

    return "\n".join(lines)


# ---------------------------------------------------------------------------
# CLI entry point
# ---------------------------------------------------------------------------


def main() -> None:
    parser = argparse.ArgumentParser(description="Format IronLayer plan as PR comment")
    parser.add_argument("--status", required=True, choices=["success", "empty", "failed"])
    parser.add_argument("--plan-json", required=True, help="Path to plan.json")
    parser.add_argument("--base-sha", required=True)
    parser.add_argument("--head-sha", required=True)
    parser.add_argument("--error", default="")
    parser.add_argument(
        "--advisory-json",
        default="",
        help="Path to advisory.json (optional, from fetch_advisory.py)",
    )
    parser.add_argument("--output", required=True, help="Output markdown file path")
    args = parser.parse_args()

    # Load advisory JSON if provided.
    advisory: dict | None = None
    if args.advisory_json:
        advisory_path = Path(args.advisory_json)
        if advisory_path.exists():
            try:
                advisory_data = json.loads(advisory_path.read_text())
                if advisory_data:  # Skip empty dicts.
                    advisory = advisory_data
            except (json.JSONDecodeError, OSError):
                pass

    if args.status == "failed":
        md = format_failed(args.error, args.base_sha, args.head_sha)
    elif args.status == "empty":
        md = format_empty(args.base_sha, args.head_sha)
    else:
        plan_path = Path(args.plan_json)
        if not plan_path.exists():
            md = format_empty(args.base_sha, args.head_sha)
        else:
            plan = json.loads(plan_path.read_text())
            steps = plan.get("steps", [])
            if not steps:
                md = format_empty(args.base_sha, args.head_sha)
            else:
                md = format_success(plan, args.base_sha, args.head_sha, advisory)

    # Compute risk level for output.
    risk_level = "low"
    if args.status == "success":
        plan_path = Path(args.plan_json)
        if plan_path.exists():
            try:
                plan = json.loads(plan_path.read_text())
                risk_level, _ = _compute_risk(plan, advisory)
            except (json.JSONDecodeError, OSError):
                pass

    Path(args.output).write_text(md)
    print(f"Comment written to {args.output} ({len(md)} bytes)")
    print(f"risk_level={risk_level}")


if __name__ == "__main__":
    main()
