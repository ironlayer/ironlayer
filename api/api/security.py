"""Agent security, token management, and authentication for the IronLayer API.

Supports three token strategies:
1. **Short-lived JWT tokens**: Generated by the API with configurable expiry.
   Default for SaaS deployments.
2. **Customer-managed KMS**: Customers provide a KMS key ARN/URI and the
   platform exchanges short-lived tokens via KMS decrypt.  No long-lived
   PATs stored by the platform.  Supports AWS KMS and Azure Key Vault
   (auto-detected from the ``KMS_KEY_URI`` format).
3. **Air-gapped on-prem mode**: Token validation deferred to the customer's
   identity provider via OIDC.  No outbound calls required.

All Databricks PATs are stored encrypted at rest and never logged.
"""

from __future__ import annotations

import hashlib
import hmac
import ipaddress
import logging
import socket
import time
import uuid
from enum import Enum
from typing import TYPE_CHECKING, Any
from urllib.parse import urlparse

from pydantic import BaseModel, Field, SecretStr

if TYPE_CHECKING:
    from cryptography.fernet import Fernet
    from sqlalchemy.ext.asyncio import AsyncSession

logger = logging.getLogger(__name__)


def _validate_url_safe(url: str, allowed_issuer_host: str) -> None:
    """Validate that a URL is safe to fetch, preventing SSRF attacks.

    Checks:
    1. Scheme must be HTTPS.
    2. Hostname must match or be a subdomain of the allowed issuer host.
    3. Resolved IP addresses must not be in private, loopback, link-local,
       or reserved ranges (prevents SSRF to internal services, cloud
       metadata endpoints like ``169.254.169.254``, etc.).

    Parameters
    ----------
    url:
        The URL to validate before fetching.
    allowed_issuer_host:
        The hostname extracted from the configured OIDC issuer URL.
        The target URL's hostname must match this host or be a subdomain
        of it (e.g. if issuer is ``accounts.google.com``, then
        ``accounts.google.com`` and ``www.accounts.google.com`` are
        allowed, but ``evil.com`` is not).

    Raises
    ------
    PermissionError
        If the URL fails any safety check.
    """
    parsed = urlparse(url)

    # --- Scheme check ---
    if parsed.scheme != "https":
        raise PermissionError(
            f"Only HTTPS URLs are allowed for OIDC fetches, got scheme '{parsed.scheme}' in URL: {url}"
        )

    # --- Hostname extraction ---
    hostname = parsed.hostname
    if not hostname:
        raise PermissionError(f"Could not extract hostname from URL: {url}")

    # --- Subdomain match check ---
    # Normalize both to lowercase for comparison.
    hostname_lower = hostname.lower()
    allowed_lower = allowed_issuer_host.lower()

    # The hostname must either exactly match the allowed host, or be a
    # subdomain of it (i.e., end with ``.<allowed_host>``).
    if hostname_lower != allowed_lower and not hostname_lower.endswith(f".{allowed_lower}"):
        raise PermissionError(
            f"URL hostname '{hostname}' is not the allowed issuer host "
            f"'{allowed_issuer_host}' or a subdomain of it. URL: {url}"
        )

    # --- DNS resolution and IP range check ---
    try:
        addr_infos = socket.getaddrinfo(hostname, None, proto=socket.IPPROTO_TCP)
    except socket.gaierror as exc:
        raise PermissionError(f"DNS resolution failed for hostname '{hostname}': {exc}") from exc

    if not addr_infos:
        raise PermissionError(f"DNS resolution returned no results for hostname '{hostname}'")

    for addr_info in addr_infos:
        ip_str = addr_info[4][0]
        try:
            addr = ipaddress.ip_address(ip_str)
        except ValueError as exc:
            raise PermissionError(f"Invalid IP address '{ip_str}' from DNS resolution: {exc}") from exc

        if addr.is_private or addr.is_loopback or addr.is_link_local or addr.is_reserved:
            raise PermissionError(
                f"URL '{url}' resolves to private/reserved IP: {ip_str}. "
                f"OIDC endpoints must resolve to public IP addresses."
            )


class AuthMode(str, Enum):
    """Supported authentication modes."""

    JWT = "jwt"
    KMS_EXCHANGE = "kms_exchange"
    OIDC_ONPREM = "oidc_onprem"
    DEVELOPMENT = "development"


class TokenClaims(BaseModel):
    """Decoded token claims."""

    sub: str = Field(..., description="Subject (user or service identity)")
    tenant_id: str = Field(..., description="Tenant identifier")
    iss: str = Field(default="ironlayer", description="Issuer")
    iat: float = Field(default_factory=lambda: time.time(), description="Issued at (epoch)")
    exp: float = Field(
        default_factory=lambda: time.time() + 3600,
        description="Expiration time (epoch)",
    )
    scopes: list[str] = Field(
        default_factory=lambda: ["read", "write"],
        description="Granted permission scopes",
    )
    jti: str = Field(
        default_factory=lambda: uuid.uuid4().hex,
        description="JWT ID for replay protection",
    )
    identity_kind: str = Field(
        default="user",
        description="Token identity kind: 'user' or 'service'",
    )
    role: str | None = Field(
        default=None,
        description="RBAC role claim (e.g. 'admin', 'engineer', 'viewer')",
    )


class KmsProvider(str, Enum):
    """Supported KMS providers for envelope encryption."""

    AWS_KMS = "aws_kms"
    AZURE_KEYVAULT = "azure_keyvault"
    AUTO = "auto"


class TokenConfig(BaseModel):
    """Configuration for token generation and validation."""

    auth_mode: AuthMode = AuthMode.DEVELOPMENT
    jwt_secret: SecretStr
    jwt_algorithm: str = "HS256"
    token_ttl_seconds: int = 3600
    refresh_token_ttl_seconds: int = 86400
    kms_key_arn: str | None = None  # AWS ARN or Azure Key Vault key URI
    kms_provider: KmsProvider = KmsProvider.AUTO
    oidc_issuer_url: str | None = None
    oidc_audience: str | None = None
    max_token_ttl_seconds: int = 86400  # Hard cap: 24 hours

    def resolve_kms_provider(self) -> KmsProvider:
        """Auto-detect the KMS provider from the key URI format.

        - AWS ARN: ``arn:aws:kms:...``
        - Azure Key Vault: ``https://<vault>.vault.azure.net/keys/<name>``
        """
        if self.kms_provider != KmsProvider.AUTO:
            return self.kms_provider
        uri = self.kms_key_arn or ""
        if uri.startswith("arn:aws:kms:"):
            return KmsProvider.AWS_KMS
        if ".vault.azure.net/" in uri:
            return KmsProvider.AZURE_KEYVAULT
        # Default to AWS for backward compatibility
        return KmsProvider.AWS_KMS


class OIDCProvider:
    """OIDC identity provider integration for on-prem deployments.

    Handles OIDC discovery, JWKS key caching, and token validation
    against a customer's identity provider (Okta, Azure AD, Auth0, etc.).

    The provider caches JWKS keys for performance and refreshes them
    when key rotation is detected (unknown kid in token header).
    """

    def __init__(
        self,
        issuer_url: str,
        audience: str | None = None,
        *,
        jwks_cache_ttl_seconds: int = 3600,
    ) -> None:
        self._issuer_url = issuer_url.rstrip("/")
        self._audience = audience
        self._cache_ttl = jwks_cache_ttl_seconds
        self._jwks: dict[str, Any] | None = None
        self._jwks_fetched_at: float = 0.0
        self._discovery: dict[str, Any] | None = None

        # Extract the allowed issuer hostname for SSRF validation.
        parsed_issuer = urlparse(self._issuer_url)
        issuer_host = parsed_issuer.hostname
        if not issuer_host:
            raise PermissionError(f"Could not extract hostname from OIDC issuer URL: {issuer_url}")
        self._allowed_issuer_host: str = issuer_host

    def _fetch_discovery(self) -> dict[str, Any]:
        """Fetch the OIDC discovery document from the well-known endpoint.

        Validates the discovery URL against SSRF before fetching.
        """
        import json
        import urllib.request

        discovery_url = f"{self._issuer_url}/.well-known/openid-configuration"

        # SSRF protection: validate the URL before fetching.
        _validate_url_safe(discovery_url, self._allowed_issuer_host)

        try:
            with urllib.request.urlopen(discovery_url, timeout=10) as resp:
                data = json.loads(resp.read().decode("utf-8"))
        except PermissionError:
            raise  # Re-raise SSRF validation errors without wrapping
        except Exception as exc:
            raise PermissionError(f"Failed to fetch OIDC discovery document from {discovery_url}: {exc}") from exc

        required_fields = {"issuer", "jwks_uri", "id_token_signing_alg_values_supported"}
        missing = required_fields - set(data.keys())
        if missing:
            raise PermissionError(f"OIDC discovery document missing required fields: {sorted(missing)}")

        self._discovery = data
        return data

    def _fetch_jwks(self) -> dict[str, Any]:
        """Fetch JSON Web Key Set from the provider's JWKS endpoint.

        Validates the JWKS URI against SSRF before fetching.  This is
        critical because the ``jwks_uri`` is taken from the discovery
        document, which could be controlled by an attacker if the OIDC
        issuer URL is compromised.
        """
        import json
        import urllib.request

        if self._discovery is None:
            self._fetch_discovery()

        jwks_uri = self._discovery["jwks_uri"]  # type: ignore[index]

        # SSRF protection: validate the JWKS URI before fetching.
        _validate_url_safe(jwks_uri, self._allowed_issuer_host)

        try:
            with urllib.request.urlopen(jwks_uri, timeout=10) as resp:
                data = json.loads(resp.read().decode("utf-8"))
        except PermissionError:
            raise  # Re-raise SSRF validation errors without wrapping
        except Exception as exc:
            raise PermissionError(f"Failed to fetch JWKS from {jwks_uri}: {exc}") from exc

        if "keys" not in data or not data["keys"]:
            raise PermissionError("JWKS response contains no keys")

        self._jwks = data
        self._jwks_fetched_at = time.time()
        return data

    def _get_signing_key(self, kid: str) -> Any:
        """Retrieve the signing key matching the token's key ID.

        Implements key rotation detection: if the kid is not found in
        the cached JWKS, forces a refresh before failing.
        """
        now = time.time()
        cache_expired = (now - self._jwks_fetched_at) > self._cache_ttl

        if self._jwks is None or cache_expired:
            self._fetch_jwks()

        # Search for the key by kid
        for key_data in self._jwks.get("keys", []):  # type: ignore[union-attr]
            if key_data.get("kid") == kid:
                return key_data

        # Key not found -- force refresh (key rotation)
        if not cache_expired:
            logger.info("Key ID '%s' not found in cached JWKS; refreshing", kid)
            self._fetch_jwks()
            for key_data in self._jwks.get("keys", []):  # type: ignore[union-attr]
                if key_data.get("kid") == kid:
                    return key_data

        raise PermissionError(f"No signing key found for kid='{kid}' in JWKS from {self._issuer_url}")

    def validate_token(self, token: str) -> TokenClaims:
        """Validate an OIDC token and return IronLayer TokenClaims.

        Steps:
        1. Decode the token header to extract kid.
        2. Fetch the matching signing key from the provider's JWKS.
        3. Validate signature, expiry, issuer, and audience.
        4. Map OIDC standard claims to IronLayer TokenClaims.

        Security:
            The ``alg`` header from the unverified token is intentionally
            ignored.  Trusting it would allow an algorithm confusion attack
            where an attacker sets ``alg: HS256`` to trick PyJWT into using
            the JWKS RSA public key as a symmetric HMAC secret, enabling
            token forgery.  The algorithm list is hardcoded to ``["RS256"]``.
        """
        try:
            import jwt
        except ImportError:
            raise PermissionError(
                "PyJWT with cryptography extras required for OIDC validation. Install with: pip install 'PyJWT[crypto]'"
            )

        # Decode header without verification to extract kid only.
        # SECURITY: We intentionally ignore the 'alg' claim from the
        # unverified header to prevent algorithm confusion attacks.
        try:
            unverified_header = jwt.get_unverified_header(token)
        except jwt.exceptions.DecodeError as exc:
            raise PermissionError(f"Invalid token header: {exc}") from exc

        kid = unverified_header.get("kid")

        if not kid:
            raise PermissionError("Token header missing 'kid' claim")

        # Get the signing key
        key_data = self._get_signing_key(kid)

        # Build the public key from JWK
        try:
            from jwt.algorithms import RSAAlgorithm

            public_key = RSAAlgorithm.from_jwk(key_data)
        except Exception as exc:
            raise PermissionError(f"Failed to construct public key from JWK: {exc}") from exc

        # Validate the token.
        # SECURITY: algorithms is hardcoded to RS256 only.  OIDC identity
        # providers sign tokens with asymmetric RSA keys; symmetric
        # algorithms (HS256/HS384/HS512) are never accepted here.
        decode_options: dict[str, Any] = {
            "verify_exp": True,
            "verify_iss": True,
            "verify_aud": self._audience is not None,
        }

        try:
            payload = jwt.decode(
                token,
                public_key,  # type: ignore[arg-type]
                algorithms=["RS256"],
                issuer=self._issuer_url,
                audience=self._audience,
                options=decode_options,  # type: ignore[arg-type]
            )
        except jwt.ExpiredSignatureError:
            raise PermissionError("OIDC token has expired")
        except jwt.InvalidIssuerError:
            raise PermissionError(f"OIDC token issuer mismatch. Expected: {self._issuer_url}")
        except jwt.InvalidAudienceError:
            raise PermissionError(f"OIDC token audience mismatch. Expected: {self._audience}")
        except jwt.InvalidTokenError as exc:
            raise PermissionError(f"Invalid OIDC token: {exc}") from exc

        # Map OIDC claims to IronLayer TokenClaims
        return self._map_claims(payload)

    @staticmethod
    def _map_claims(payload: dict[str, Any]) -> TokenClaims:
        """Map OIDC standard claims to IronLayer TokenClaims.

        OIDC claim mapping:
        - sub -> sub (subject identity)
        - tenant_id: from custom claim 'tenant_id', 'org_id', or 'azp'
        - scopes: from 'scope' (space-separated string) or 'scp' (list)
        """
        sub = payload.get("sub", "")
        if not sub:
            raise PermissionError("OIDC token missing 'sub' claim")

        # Extract tenant_id from various possible claim names
        tenant_id = payload.get("tenant_id") or payload.get("org_id") or payload.get("azp") or payload.get("client_id")
        if not tenant_id:
            raise PermissionError(
                "OIDC token missing tenant identifier. Expected one of: tenant_id, org_id, azp, client_id"
            )

        # Extract scopes
        raw_scopes = payload.get("scope", payload.get("scp", ""))
        if isinstance(raw_scopes, str):
            scopes = [s.strip() for s in raw_scopes.split() if s.strip()]
        elif isinstance(raw_scopes, list):
            scopes = raw_scopes
        else:
            scopes = ["read"]

        # Map OIDC scopes to IronLayer scopes
        ironlayer_scopes: list[str] = []
        if any(s in scopes for s in ("read", "openid", "profile")):
            ironlayer_scopes.append("read")
        if any(s in scopes for s in ("write", "admin")):
            ironlayer_scopes.append("write")
        if not ironlayer_scopes:
            ironlayer_scopes = ["read"]  # default to read-only

        return TokenClaims(
            sub=sub,
            tenant_id=str(tenant_id),
            iss=payload.get("iss", ""),
            iat=payload.get("iat", time.time()),
            exp=payload.get("exp", time.time() + 3600),
            scopes=ironlayer_scopes,
            jti=payload.get("jti", uuid.uuid4().hex),
            identity_kind=payload.get("identity_kind", "user"),
        )


class AzureKeyVaultProvider:
    """Azure Key Vault envelope encryption provider.

    Uses Azure Key Vault's ``wrap_key`` / ``unwrap_key`` operations for
    envelope encryption.  A random AES-256 data key is generated locally,
    wrapped (encrypted) by the Key Vault RSA key, and stored alongside the
    Fernet-encrypted token payload.

    Requires:
    - ``azure-keyvault-keys`` SDK
    - ``azure-identity`` SDK
    - A Key Vault key URI in the format:
      ``https://<vault-name>.vault.azure.net/keys/<key-name>[/<version>]``

    Authentication uses ``DefaultAzureCredential`` which supports managed
    identity, environment variables, Azure CLI, and other mechanisms.
    """

    def __init__(self, key_uri: str) -> None:
        self._key_uri = key_uri
        self._vault_url, self._key_name, self._key_version = self._parse_key_uri(key_uri)
        self._client: Any | None = None

    @staticmethod
    def _parse_key_uri(uri: str) -> tuple[str, str, str | None]:
        """Parse an Azure Key Vault key URI.

        Accepts:
        - ``https://myvault.vault.azure.net/keys/mykey``
        - ``https://myvault.vault.azure.net/keys/mykey/abc123``

        Returns ``(vault_url, key_name, key_version_or_none)``.
        """
        from urllib.parse import urlparse

        parsed = urlparse(uri)
        if not parsed.hostname or ".vault.azure.net" not in parsed.hostname:
            raise ValueError(
                f"Invalid Azure Key Vault URI: {uri}. "
                "Expected format: https://<vault>.vault.azure.net/keys/<name>[/<version>]"
            )

        vault_url = f"{parsed.scheme}://{parsed.hostname}"
        path_parts = [p for p in parsed.path.strip("/").split("/") if p]

        if len(path_parts) < 2 or path_parts[0] != "keys":
            raise ValueError(
                f"Invalid Key Vault key path: {parsed.path}. Expected /keys/<name> or /keys/<name>/<version>"
            )

        key_name = path_parts[1]
        key_version = path_parts[2] if len(path_parts) >= 3 else None

        return vault_url, key_name, key_version

    def _get_client(self) -> Any:
        """Lazy-initialize the Key Vault CryptographyClient."""
        if self._client is not None:
            return self._client

        try:
            from azure.identity import DefaultAzureCredential
            from azure.keyvault.keys.crypto import CryptographyClient
        except ImportError as exc:
            raise ImportError(
                "Azure Key Vault SDK required. Install with: pip install azure-keyvault-keys azure-identity"
            ) from exc

        credential = DefaultAzureCredential()

        # Build the key ID URL
        key_id = f"{self._vault_url}/keys/{self._key_name}"
        if self._key_version:
            key_id += f"/{self._key_version}"

        self._client = CryptographyClient(key_id, credential)
        return self._client

    def wrap_key(self, plaintext_key: bytes) -> bytes:
        """Wrap (encrypt) a data key using the Key Vault RSA key.

        Uses RSA-OAEP-256 algorithm for key wrapping.

        Parameters
        ----------
        plaintext_key:
            The raw AES-256 key bytes to wrap.

        Returns
        -------
        bytes
            The wrapped (encrypted) key bytes.
        """
        from azure.keyvault.keys.crypto import KeyWrapAlgorithm

        client = self._get_client()
        result = client.wrap_key(KeyWrapAlgorithm.rsa_oaep_256, plaintext_key)
        return result.encrypted_key

    def unwrap_key(self, wrapped_key: bytes) -> bytes:
        """Unwrap (decrypt) a data key using the Key Vault RSA key.

        Parameters
        ----------
        wrapped_key:
            The wrapped key bytes to decrypt.

        Returns
        -------
        bytes
            The original plaintext AES-256 key bytes.
        """
        from azure.keyvault.keys.crypto import KeyWrapAlgorithm

        client = self._get_client()
        result = client.unwrap_key(KeyWrapAlgorithm.rsa_oaep_256, wrapped_key)
        return result.key

    def close(self) -> None:
        """Close the underlying HTTP client."""
        if self._client is not None:
            self._client.close()
            self._client = None


class TokenManager:
    """Generates and validates authentication tokens.

    Supports JWT (PyJWT), KMS envelope encryption (AWS KMS or Azure Key Vault
    with Fernet), and OIDC on-prem validation (JWKS discovery and verification).
    """

    def __init__(self, config: TokenConfig) -> None:
        self._config = config
        self._oidc_provider: OIDCProvider | None = None

    @property
    def auth_mode(self) -> AuthMode:
        return self._config.auth_mode

    def generate_token(
        self,
        subject: str,
        tenant_id: str,
        scopes: list[str] | None = None,
        ttl_seconds: int | None = None,
        identity_kind: str = "user",
        role: str | None = None,
    ) -> str:
        """Generate a short-lived authentication token.

        Parameters
        ----------
        subject:
            User or service identity.
        tenant_id:
            The tenant this token is scoped to.
        scopes:
            Permission scopes.  Defaults to ``["read", "write"]``.
        ttl_seconds:
            Token lifetime in seconds.  Capped at ``max_token_ttl_seconds``.
        identity_kind:
            Token identity kind: ``"user"`` or ``"service"``.
        role:
            RBAC role claim (e.g. ``"admin"``, ``"engineer"``, ``"viewer"``).

        Returns
        -------
        str
            An opaque token string (HMAC-signed payload in dev mode).
        """
        if ttl_seconds is None:
            ttl_seconds = self._config.token_ttl_seconds
        ttl_seconds = min(ttl_seconds, self._config.max_token_ttl_seconds)

        now = time.time()
        claims = TokenClaims(
            sub=subject,
            tenant_id=tenant_id,
            iss="ironlayer",
            iat=now,
            exp=now + ttl_seconds,
            scopes=scopes or ["read", "write"],
            identity_kind=identity_kind,
            role=role,
        )

        if self._config.auth_mode == AuthMode.DEVELOPMENT:
            return self._sign_dev_token(claims)
        elif self._config.auth_mode == AuthMode.JWT:
            return self._sign_jwt_token(claims)
        elif self._config.auth_mode == AuthMode.KMS_EXCHANGE:
            return self._sign_kms_token(claims)
        elif self._config.auth_mode == AuthMode.OIDC_ONPREM:
            raise ValueError(
                "OIDC on-prem mode does not generate tokens; tokens are issued by the customer's identity provider."
            )
        else:
            raise ValueError(f"Unsupported auth mode: {self._config.auth_mode}")

    def validate_token(self, token: str) -> TokenClaims:
        """Validate a token and return its claims.

        Raises
        ------
        PermissionError
            If the token is invalid, expired, or tampered with.
        """
        if self._config.auth_mode == AuthMode.DEVELOPMENT:
            return self._validate_dev_token(token)
        elif self._config.auth_mode == AuthMode.JWT:
            return self._validate_jwt_token(token)
        elif self._config.auth_mode == AuthMode.KMS_EXCHANGE:
            return self._validate_kms_token(token)
        elif self._config.auth_mode == AuthMode.OIDC_ONPREM:
            return self._validate_oidc_token(token)
        else:
            raise PermissionError(f"Unsupported auth mode: {self._config.auth_mode}")

    def generate_refresh_token(
        self,
        subject: str,
        tenant_id: str,
    ) -> str:
        """Generate a longer-lived refresh token for token rotation."""
        return self.generate_token(
            subject=subject,
            tenant_id=tenant_id,
            scopes=["refresh"],
            ttl_seconds=self._config.refresh_token_ttl_seconds,
        )

    # ------------------------------------------------------------------
    # Development mode (HMAC-SHA256 signed)
    # ------------------------------------------------------------------

    def _sign_dev_token(self, claims: TokenClaims) -> str:
        """Create an HMAC-signed token for development use."""
        import base64

        payload = claims.model_dump_json()
        secret = self._config.jwt_secret.get_secret_value()
        signature = hmac.new(
            secret.encode("utf-8"),
            payload.encode("utf-8"),
            hashlib.sha256,
        ).hexdigest()
        token_bytes = base64.urlsafe_b64encode(payload.encode("utf-8")).decode("ascii")
        return f"bmdev.{token_bytes}.{signature}"

    def _validate_dev_token(self, token: str) -> TokenClaims:
        """Validate a development-mode HMAC token."""
        import base64

        parts = token.split(".")
        if len(parts) != 3 or parts[0] != "bmdev":
            raise PermissionError("Invalid token format")

        try:
            payload = base64.urlsafe_b64decode(parts[1]).decode("utf-8")
        except Exception as exc:
            raise PermissionError(f"Token decode failed: {exc}") from exc

        secret = self._config.jwt_secret.get_secret_value()
        expected_sig = hmac.new(
            secret.encode("utf-8"),
            payload.encode("utf-8"),
            hashlib.sha256,
        ).hexdigest()

        if not hmac.compare_digest(parts[2], expected_sig):
            raise PermissionError("Token signature verification failed")

        try:
            claims = TokenClaims.model_validate_json(payload)
        except Exception as exc:
            raise PermissionError(f"Invalid token claims: {exc}") from exc

        if claims.exp < time.time():
            raise PermissionError("Token has expired")

        return claims

    # ------------------------------------------------------------------
    # JWT mode (production)
    # ------------------------------------------------------------------

    def _sign_jwt_token(self, claims: TokenClaims) -> str:
        """Sign a JWT token using PyJWT.

        Requires the ``pyjwt`` package to be installed.  If missing, the
        import error will propagate at startup â€” never silently fall back.
        """
        import jwt

        secret = self._config.jwt_secret.get_secret_value()
        payload = claims.model_dump()
        return jwt.encode(payload, secret, algorithm=self._config.jwt_algorithm)

    def _validate_jwt_token(self, token: str) -> TokenClaims:
        """Validate a JWT token."""
        import jwt

        secret = self._config.jwt_secret.get_secret_value()
        try:
            payload = jwt.decode(
                token,
                secret,
                algorithms=[self._config.jwt_algorithm],
            )
        except jwt.ExpiredSignatureError:
            raise PermissionError("Token has expired")
        except jwt.InvalidTokenError as exc:
            raise PermissionError(f"Invalid token: {exc}") from exc

        return TokenClaims(**payload)

    # ------------------------------------------------------------------
    # KMS exchange mode (AWS KMS or Azure Key Vault)
    # ------------------------------------------------------------------

    def _sign_kms_token(self, claims: TokenClaims) -> str:
        """Generate a token using KMS envelope encryption.

        Supports two providers (auto-detected from ``kms_key_arn``):

        - **AWS KMS**: ``arn:aws:kms:<region>:<account>:key/<id>``
        - **Azure Key Vault**: ``https://<vault>.vault.azure.net/keys/<name>``

        Token format: ``bmkms.<base64_encrypted_data_key>.<fernet_ciphertext>``
        """
        if not self._config.kms_key_arn:
            raise ValueError("KMS key URI not configured (set KMS_KEY_URI)")

        provider = self._config.resolve_kms_provider()
        payload = claims.model_dump_json()

        if provider == KmsProvider.AZURE_KEYVAULT:
            return self._sign_kms_azure(payload)
        return self._sign_kms_aws(payload)

    def _sign_kms_aws(self, payload: str) -> str:
        """AWS KMS envelope encryption: generate data key + Fernet encrypt."""
        try:
            import boto3
        except ImportError:
            raise PermissionError("AWS KMS unavailable: boto3 not installed. Cannot sign tokens in KMS mode.")

        try:
            kms_client = boto3.client("kms")
            data_key_response = kms_client.generate_data_key(
                KeyId=self._config.kms_key_arn,
                KeySpec="AES_256",
            )
            plaintext_key = data_key_response["Plaintext"]
            encrypted_key = data_key_response["CiphertextBlob"]
        except Exception as exc:
            logger.error("AWS KMS generate_data_key failed: %s", exc)
            raise PermissionError(f"KMS token generation failed: {exc}") from exc

        return self._fernet_seal(plaintext_key, encrypted_key, payload)

    def _sign_kms_azure(self, payload: str) -> str:
        """Azure Key Vault envelope encryption: local AES key + Key Vault wrap."""
        import os

        try:
            akv = AzureKeyVaultProvider(self._config.kms_key_arn or "")
        except (ImportError, ValueError) as exc:
            raise PermissionError(
                "Azure Key Vault unavailable: azure-keyvault-keys not installed. Cannot sign tokens in Azure KMS mode."
            ) from exc

        # Generate a random AES-256 data key locally.
        plaintext_key = os.urandom(32)

        try:
            encrypted_key = akv.wrap_key(plaintext_key)
        except Exception as exc:
            logger.error("Azure Key Vault wrap_key failed: %s", exc)
            raise PermissionError(f"Azure Key Vault token generation failed: {exc}") from exc
        finally:
            akv.close()

        return self._fernet_seal(plaintext_key, encrypted_key, payload)

    @staticmethod
    def _fernet_seal(
        plaintext_key: bytes,
        encrypted_key: bytes,
        payload: str,
    ) -> str:
        """Encrypt a payload with Fernet using a data key and return a bmkms token."""
        import base64

        from cryptography.fernet import Fernet

        fernet_key = base64.urlsafe_b64encode(plaintext_key[:32])
        fernet = Fernet(fernet_key)
        encrypted_payload = fernet.encrypt(payload.encode("utf-8"))

        encoded_key = base64.urlsafe_b64encode(encrypted_key).decode("ascii")
        encoded_payload = encrypted_payload.decode("ascii")

        return f"bmkms.{encoded_key}.{encoded_payload}"

    def _validate_kms_token(self, token: str) -> TokenClaims:
        """Validate a KMS-encrypted token using envelope decryption.

        Routes to AWS KMS or Azure Key Vault based on the configured provider.
        """
        parts = token.split(".")
        if len(parts) != 3 or parts[0] != "bmkms":
            raise PermissionError("Invalid KMS token format")

        provider = self._config.resolve_kms_provider()

        if provider == KmsProvider.AZURE_KEYVAULT:
            payload = self._unseal_kms_azure(parts)
        else:
            payload = self._unseal_kms_aws(parts)

        try:
            claims = TokenClaims.model_validate_json(payload)
        except Exception as exc:
            raise PermissionError(f"Invalid token claims: {exc}") from exc

        if claims.exp < time.time():
            raise PermissionError("Token has expired")

        return claims

    def _unseal_kms_aws(self, parts: list[str]) -> str:
        """Decrypt the data key via AWS KMS and Fernet-decrypt the payload."""
        try:
            import base64

            import boto3
            from cryptography.fernet import Fernet

            encrypted_key = base64.urlsafe_b64decode(parts[1])
            encrypted_payload = parts[2].encode("ascii")

            kms_client = boto3.client("kms")
            decrypt_response = kms_client.decrypt(
                CiphertextBlob=encrypted_key,
                KeyId=self._config.kms_key_arn,
            )
            plaintext_key = decrypt_response["Plaintext"]

            fernet_key = base64.urlsafe_b64encode(plaintext_key[:32])
            fernet = Fernet(fernet_key)
            return fernet.decrypt(encrypted_payload).decode("utf-8")

        except ImportError as exc:
            raise PermissionError(
                "AWS KMS unavailable: boto3 or cryptography not installed. Cannot validate tokens in KMS mode."
            ) from exc
        except Exception as exc:
            raise PermissionError(f"AWS KMS token validation failed: {exc}") from exc

    def _unseal_kms_azure(self, parts: list[str]) -> str:
        """Decrypt the data key via Azure Key Vault and Fernet-decrypt the payload."""
        import base64

        from cryptography.fernet import Fernet

        try:
            akv = AzureKeyVaultProvider(self._config.kms_key_arn or "")
        except (ImportError, ValueError) as exc:
            raise PermissionError(f"Azure Key Vault unavailable for token validation: {exc}") from exc

        try:
            encrypted_key = base64.urlsafe_b64decode(parts[1])
            encrypted_payload = parts[2].encode("ascii")

            plaintext_key = akv.unwrap_key(encrypted_key)

            fernet_key = base64.urlsafe_b64encode(plaintext_key[:32])
            fernet = Fernet(fernet_key)
            return fernet.decrypt(encrypted_payload).decode("utf-8")
        except Exception as exc:
            raise PermissionError(f"Azure Key Vault token validation failed: {exc}") from exc
        finally:
            akv.close()

    # ------------------------------------------------------------------
    # OIDC on-prem mode
    # ------------------------------------------------------------------

    def _get_oidc_provider(self) -> OIDCProvider:
        """Return the cached OIDCProvider, creating it on first use."""
        if self._oidc_provider is None:
            if not self._config.oidc_issuer_url:
                raise PermissionError("OIDC issuer URL not configured")
            self._oidc_provider = OIDCProvider(
                issuer_url=self._config.oidc_issuer_url,
                audience=self._config.oidc_audience,
            )
        return self._oidc_provider

    def _validate_oidc_token(self, token: str) -> TokenClaims:
        """Validate an OIDC token from a customer's identity provider.

        Uses the OIDCProvider to:
        1. Fetch the OIDC discovery document from the issuer URL.
        2. Retrieve signing keys from the JWKS endpoint.
        3. Validate the JWT signature, issuer, audience, and expiry.
        4. Map standard OIDC claims to IronLayer TokenClaims.
        """
        provider = self._get_oidc_provider()
        return provider.validate_token(token)


class CredentialVault:
    """Secure storage for Databricks PATs and other secrets.

    Secrets are encrypted using Fernet symmetric encryption (AES-128-CBC
    with HMAC-SHA256) before being written to the database. The encryption
    key is derived from the platform's JWT secret using PBKDF2.

    In production, the JWT secret should be a high-entropy value stored
    in a secrets manager. The Fernet key derivation ensures that even if
    the database is compromised, credential values remain encrypted.
    """

    def __init__(self, secret: str) -> None:
        self._fernet = self._derive_fernet(secret)

    @staticmethod
    def _derive_fernet(secret: str) -> Fernet:
        """Derive a Fernet key from the JWT secret using PBKDF2."""
        import base64
        import hashlib

        from cryptography.fernet import Fernet

        # PBKDF2 with a fixed salt (the salt doesn't need to be secret for
        # this use case -- the JWT secret IS the secret). Using 480_000
        # iterations per OWASP 2023 recommendations for PBKDF2-SHA256.
        key_bytes = hashlib.pbkdf2_hmac(
            "sha256",
            secret.encode("utf-8"),
            b"ironlayer-credential-vault-v1",
            iterations=480_000,
            dklen=32,
        )
        fernet_key = base64.urlsafe_b64encode(key_bytes)
        return Fernet(fernet_key)

    def encrypt(self, plaintext: str) -> str:
        """Encrypt a plaintext credential value."""
        return self._fernet.encrypt(plaintext.encode("utf-8")).decode("ascii")

    def decrypt(self, ciphertext: str) -> str:
        """Decrypt an encrypted credential value."""
        return self._fernet.decrypt(ciphertext.encode("ascii")).decode("utf-8")

    async def store_credential(
        self,
        session: AsyncSession,
        tenant_id: str,
        credential_name: str,
        credential_value: str,
    ) -> None:
        """Encrypt and persist a credential for a tenant."""
        from core_engine.state.repository import CredentialRepository

        encrypted = self.encrypt(credential_value)
        repo = CredentialRepository(session, tenant_id=tenant_id)
        await repo.store(credential_name, encrypted)
        logger.info(
            "Stored credential '%s' for tenant '%s'",
            credential_name,
            tenant_id,
        )

    async def get_credential(
        self,
        session: AsyncSession,
        tenant_id: str,
        credential_name: str,
    ) -> str | None:
        """Retrieve and decrypt a credential. Returns None if not found."""
        from core_engine.state.repository import CredentialRepository

        repo = CredentialRepository(session, tenant_id=tenant_id)
        encrypted = await repo.get(credential_name)
        if encrypted is None:
            return None
        return self.decrypt(encrypted)

    async def delete_credential(
        self,
        session: AsyncSession,
        tenant_id: str,
        credential_name: str,
    ) -> bool:
        """Delete a credential. Returns True if it existed."""
        from core_engine.state.repository import CredentialRepository

        repo = CredentialRepository(session, tenant_id=tenant_id)
        deleted = await repo.delete(credential_name)
        if deleted:
            logger.info(
                "Deleted credential '%s' for tenant '%s'",
                credential_name,
                tenant_id,
            )
        return deleted

    async def list_credentials(
        self,
        session: AsyncSession,
        tenant_id: str,
    ) -> list[str]:
        """List credential names (not values) for a tenant."""
        from core_engine.state.repository import CredentialRepository

        repo = CredentialRepository(session, tenant_id=tenant_id)
        return await repo.list_names()
